# Алгоритмы и структуры данных

## Модуль 1

### Задача 1

**1.3 Если в числе содержится только один бит со значением 1, записать в выходной поток `OK`. Иначе записать `FAIL`**

### Задача 2

**2.4 Дан отсортированный массив различных целых чисел `A[0..n-1]` и массив целых чисел `B[0..m-1]`. Для каждого элемента массива `B[i]` найдите минимальный индекс элемента массива `A[k]`, ближайшего по значению к `B[i]`.**  
**Требования:** Время работы поиска для каждого элемента `B[i]`: `O(log(k))`.  
Внимание! В этой задаче для каждого `B[i]` сначала нужно определить диапазон для бинарного поиска размером порядка `k` с помощью экспоненциального поиска, а потом уже в нем делать бинарный поиск.  
`n ≤ 110000, m ≤ 1000`.

### Задача 3

Во всех задачах из следующего списка следует написать структуру данных, обрабатывающую команды `push` и `pop`.  
_Формат входных данных:_  
В первой строке количество команд `n`. `n ≤ 1000000`.  
Каждая команда задаётся как 2 целых числа: `a b`.   
- `a = 1 - push front  `
- `a = 2 - pop front  `
- `a = 3 - push back  `
- `a = 4 - pop back  `

Команды добавления элемента `1` и `3` заданы с неотрицательным параметром `b`.
Для очереди используются команды `2` и `3`. Для дека используются все четыре команды.
Если дана команда `pop`, то число `b` - ожидаемое значение. Если команда `pop` вызвана для пустой структуры данных, то ожидается `-1`.
_Формат выходных данных:_  
Требуется напечатать `YES` - если все ожидаемые значения совпали. Иначе, если хотя бы одно ожидание не оправдалось, то напечатать `NO`.

**3.1. Реализовать очередь с динамическим зацикленным буфером.**  
**Требования:** Очередь должна быть реализована в виде класса.

### Задача 4  

**Требование для всех вариантов Задачи 4:**  
- Решение всех задач данного раздела предполагает использование кучи, реализованной в виде шаблонного класса.
- Решение должно поддерживать передачу функции сравнения снаружи.
- Куча должна быть динамической.

**4.1. Слияние массивов**  
Напишите программу, которая использует кучу для слияния K отсортированных массивов суммарной длиной `N`.  
**Требования:** время работы `O(N * logK)`. Ограничение на размер кучи `O(K)`.  
_Формат входных данных:_  
Сначала вводится количество массивов K. Затем по очереди размер каждого массива и элементы массива. Каждый массив упорядочен по возрастанию.  
_Формат выходных данных:_  
Итоговый отсортированный массив.

### Задача 5

**Требование для всех вариантов Задачи 5:**  
- Во всех задачах данного раздела необходимо реализовать и использовать сортировку слиянием в виде шаблонной функции.
- Решение должно поддерживать передачу функции сравнения снаружи.
- Общее время работы алгоритма `O(n log n)`.

**5.4. Закраска прямой №2**  
На числовой прямой окрасили `N` отрезков. Известны координаты левого и правого концов каждого отрезка (`Li` и `Ri`). Найти сумму длин частей числовой прямой, окрашенных ровно в один слой.

### Задача 6

Дано множество целых чисел из [0..10^9] размера n.
Используя алгоритм поиска k-ой порядковой статистики, требуется найти следующие параметры множества:
1)	10%  перцентиль
2)	медиана
3)	90%  перцентиль

**Требования:** 
- Дополнительная память: `O(n)`
- Среднее время работы: `O(n)`
- Должна быть отдельно выделенная функция `Partition()`
- Рекурсия запрещена
- Решение должно поддерживать передачу функции сравнения снаружи

Функцию `Partition` следует реализовывать методом прохода двумя итераторами в одном направлении. Описание для случая прохода от начала массива к концу:
- Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
- Во время работы `Partition` в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
- Итератор (индекс) `i` указывает на начало группы элементов, строго бОльших опорного.
- Итератор `j` больше `i`, итератор `j` указывает на первый нерассмотренный элемент.
- Шаг алгоритма. Рассматривается элемент, на который указывает `j`. Если он больше опорного, то сдвигаем `j`.   
Если он не больше опорного, то меняем `a[i]` и `a[j]` местами, сдвигаем `i` и сдвигаем `j`.
- В конце работы алгоритма меняем опорный и элемент, на который указывает итератор `i`.

**6.1. Реализуйте стратегию выбора опорного элемента “медиана трёх”. Функцию Partition реализуйте методом прохода двумя итераторами от начала массива к концу.**

### Задача 7
**7.1. MSD для строк**
Дан массив строк. Количество строк не больше `10^5`. Отсортировать массив методом поразрядной сортировки MSD по символам. Размер алфавита - `256` символов. Последний символ строки = `‘\0’`.
